function MPC_Exercise1


% Очистка рабочей области, закрытие открытых фигур, очистка окна команд
clear all
close all
clc


% Установка параметров
tol_opt       = 1e-8;
options = optimset('Display','off',...
    'TolFun', tol_opt,...
    'MaxIter', 10000,...
    'Algorithm', 'active-set',...
    'TolConSQP', 1e-6);

warning off

% Количество MPC итераций (длина симуляции)
mpciterations = 50;

% Время предсказания (непрерывный горизонт предсказания)
T = ???;

% Шаги дискретизации
delta = ???;

% Горизонт предсказания
N = ???;

% Динамика системы (непрерывная)
Ac = ???;
Bc = ???;

n = length(Ac(1,:)); % размерность состояния
m = length(Bc(1,:)); % размерность управления

sysc = ss(Ac,Bc,eye(n),zeros(n,m));

% Динамика системы (дискретное время)
sysd = c2d(sysc, delta, 'zoh');
Ad = sysd.A;
Bd = sysd.B;

% Конечное (терминальное) состояние
xTerm = ???;

% Параметры стоимости (веса)
Q = ???;
R = ???;

% Начальные условия
tmeasure        = 0.0;   % начальное время
xmeasure        = ???;   % начальное состояние

% Начальное предсказание последовательности управления
u0              = ???;
% Начальное предсказание последовательности состояний (порядок: [x_1(0);x_2(0);x_1(1);x_2(1);...])
x0              = ???;

% Ограничения-неравентсва (H_x*x <= k_x   и   H_u*u <= k_u)
H_x = ???;
k_x = ???;

H_u = ???;
k_u = ???;

% ==============================================
% Реализация MPC итерации
% ==============================================

% Используйте функцию quadprog для решения задачи управления
% quadprog имеет следующую структуру
%
% x = quadprog(H,f,A,b,Aeq,beq,[],[],x0,options)
%
% x:        оптимальное решение
%
% H:        квадратичная часть стоимости
% f:        линейная часть стоимости
% A, b:     ограничения-неравенства A x <= b
% Aeq, beq: ограничения-равенства Aeq x = beq
% x0:       начальное предсказание для оптимизации
% options:  параметры решателя


% Установка переменных для вывода
t = [];
x = [];
u = [];

% Определите матрицы для quadprog
% Состояние, управление, терминальные ограничения и ограничения для
% динамики
% Используйте функцию repmat при необходимости
 
    % Оформление ограничений
    ???
    

% Вывод заголовка
fprintf('   k  |      u(k)        x(1)        x(2)     Time \n');
fprintf('---------------------------------------------------\n');


for ii = 1:mpciterations
       
    %Обновление ограничений (начальное ограничение) на основании текущего состояния x_measure
    ???;   
    
    t_Start = tic;
    
    % Решите задачу оптимизации
    solutionOL = ???;
    
    % Получите последовательности оптимальных предсказанных состояний и
    % управлений
    x_OL = ???;
    u_OL = ???;
    
    t_Elapsed = toc( t_Start );
    
    % Сохранение данных обратной связи
    t = [ t, tmeasure ];
    x = [ x, xmeasure ];
    u = [ u, u_OL(:,1) ];
    
    % Обновите параметры системы
    xmeasure = ???;
    tmeasure = ???;
    
    % Подготовьте начальное предсказание для следующего шага (возьмите конец оптимального 
    % решения и добавьте последний шаг)
    x0 = ???;
    u0 = ???;
    
    
    % Вывод результатов
    fprintf(' %3d  | %+11.6f %+11.6f %+11.6f  %+6.3f\n', ii, u(end),...
        x(1,end), x(2,end),t_Elapsed);
    
    % Построение последовательности состояний на графике (с и без обратной связи)
    f1 = figure(1);
    plot(x(1,:),x(2,:),'b'), grid on, hold on,
    plot(x_OL(1,:),x_OL(2,:),'g')
    plot(x(1,:),x(2,:),'ob')
    xlabel('x(1)')
    ylabel('x(2)')
    title('state space')
    drawnow
    
    % Построение последовательности управления (с и без обратной связи)
    f2 = figure(2);
    stairs(t(end)+delta*(0:1:N-1),u_OL), grid on, hold on,
    plot(t(end),u(end),'bo')
    xlabel('prediction time')
    ylabel('uOL')
    drawnow
    
end


f3 = figure(3);
stairs(t,u);
xlabel('t')
ylabel('u')
title('closed-loop input')


end